#!/usr/bin/env node

process.env.DEBUG = process.env.DEBUG || 'http2,http2:error*,ssl:certificate*'

const app       = require('express')()
const debugLog  = require('debug')('http2')
const {resolve} = require('path')

const {
  sslPort, httpPort, address, silent, push, cache, maxAge, trustCert,
  log, cors, ssl, compression, autoindex, index, URL, serverType, generateCert,
  proxy,
  args: [
    path = '.'
  ]
} = require('./options')

const onServerStart = () => {
  debugLog(`${serverType} server started on ${URL}`)
  debugLog(`Serve static from ${resolve(path)}`)
}

const startRedirectServer = () =>
  require('express')()
    .use(require('redirect-https')({port: sslPort}))
    .listen(httpPort, () => debugLog(`Http redirects to https from ${httpPort}`))


if (generateCert)
  return require('./generateCertificates').generate()

if (trustCert)
  return require('./generateCertificates').trust()

// if (cors)
//   app.use(require('cors')())
//
// if (compression)
//   app.use(require('shrink-ray-current')())
//
// if (ssl && push)
//   require('./naivePush').map(x => app.use(x))
//
// if (!silent)
//   app.use(require('morgan')(log))
//
// app.use((req, res, next) => {
//   if (!cache) res.set('Cache-Control', 'no-cache')
//   next()
// })
//
// app.use(require('serve-static')(path, {
//   index, maxAge, cacheControl: Boolean(cache || maxAge)
// }))
//
// if (require('./options')['404']) {
//   const errorPage = require('fs').readFileSync(require('./options')['404'], 'utf-8')
//   app.use((req, res) => res.status(404).send(errorPage).end())
// }
//
// if (proxy) {
//   app.use((req, res) =>
//     require('http-proxy').createProxyServer({
//       secure: false,
//       xfwd: true,
//       changeOrigin: true,
//     }).web(req, res, { target: proxy })
//   )
// }
//
// if (autoindex)
//   app.use(require('serve-index')(path))
//
// require('./ssl').then(options => {
//   const http2 = require('http2');
//   const path = require('path');
//   const mime = require('mime-types');
//
//   const {
//     HTTP2_HEADER_PATH,
//     HTTP2_HEADER_METHOD,
//     HTTP_STATUS_NOT_FOUND,
//     HTTP_STATUS_INTERNAL_SERVER_ERROR
//   } = http2.constants;
//
//   const certs = {
//     key: options.key || './certs/key.pem',
//     cert: options.cert || './certs/cert.pem'
//   };
//
//   const server = http2.createSecureServer(certs);
//
//   const serverRoot = "./";

  function respondToStreamError(err, stream) {
    if (err.code === 'ENOENT') {
      stream.respond({ ":status": HTTP_STATUS_NOT_FOUND });
    } else {
      stream.respond({ ":status": HTTP_STATUS_INTERNAL_SERVER_ERROR });
    }
    stream.end();
  }

  server.on('stream', (stream, headers) => {
    const reqPath = headers[HTTP2_HEADER_PATH];
    const reqMethod = headers[HTTP2_HEADER_METHOD];

    let fullPath = path.join(serverRoot, reqPath);
    let responseMimeType = mime.lookup(fullPath);

    if (!responseMimeType) {
      fullPath = path.join(fullPath, 'index.html');
      responseMimeType = mime.lookup(fullPath);
    }
    stream.respondWithFile(fullPath, {
      'content-type': responseMimeType
    }, {
      onError: (err) => respondToStreamError(err, stream)
    });
  });

  server.listen(ssl ? sslPort : httpPort);

  onServerStart();
  if (ssl) {
    startRedirectServer();
  }
});
